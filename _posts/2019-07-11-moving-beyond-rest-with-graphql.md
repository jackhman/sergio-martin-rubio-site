---
title: Moving Beyond REST with GraphQL
tags: [Java]
style: fill
color: success
description: GraphQL is an innovative query language which allows you to get what you ask for in a single request. What are you waiting for to know more about GraphQL?
---

{%- capture list_items -%}
Introduction
Specification
Query
Mutation
Conclusion
{%- endcapture -%}

{% include elements/list.html %}

## Introduction

[**GraphQL**](https://graphql.org/) is a **query language** that matches up with **Domain Driven Design**, so you can use your existing entities or models in your GraphQL design.

This query language was created by **Facebook** and **open sourced** later **in 2015**, and since then it has been **maitained by the community**.

To start using **GraphQL** you will have to learn a **new specification**, because it is not a simple implementation, however it is pretty **simple** and if you are familiar with other query languages it will take you a couple of days to understand how it works. The [GraphQL spec](https://graphql.github.io/graphql-spec/June2018/#) is very well documented and shows you how to use operations like queries or mutations, define schemas or what good practicies you should follow.

Companies like _Pivotal_ are already supporting _GraphQL_, in fact it was one of the topics presented in [Spring IO 2019](https://2019.springio.net/sessions/moving-beyond-rest-graphql-and-java-spring).

## Specification

This API Query Language allows you to retrive data from a service in one go. How can I do that? A single endpoint is exposed by GraphQL, and given a schema which contains your models and operations, you can make HTTP requests to this single endpoint by providing operation names, payload and variables. 

GraphQL supports both, GET and POST HTTP methods. In case of GET, we have to use a query parameter (`?query={operationName{field}}`) and do URL encoding. On the other hand, we could do a standard POST request with a JSON payload.

e.g.

```json
{
  "query": "...",
  "operationName": "...",
}
```

### Query

Queries are read operations, and they correspond with the R (Read) from the four basic functions of persistent storage (cRud). You could do other kind of operations, but it is important to follow these conventions. Here is an example:

```graphql
query {
  findHotelById(id: 2) {
      name
      address
      room {
          type
      }
  }
}
```

The _findHotelById_ is the operation of the query, and everything else inside the operation is called _payload_. We can use arguments like the one in the previos example (id: 2), that will return the Hotel with id 2.

Queries also support _dynamic_ arguments, and provides a way to pass them as JSON in the operation. We will use them like this:
```graphql
query MyQuery($hotelId:ID) {
  findHotelById(id:$hotelId) {
    name
    room {
      type
      occupants
    }
  }
}
```

```json
{
  "hotelId": "1"
}
```
>You could use the shorthand syntax and omit both the _query_ keyword and the _query name_, but it is a good practice to use these to make our code more readable, and they can be useful for debugging or identify different GraphQL requests.

In case we have to create a complex query we could use _Fragments_. Fragments are reusable blocks that contain set of fields. For example:
```
query MyQuery {
  firstHotel: findHotelById(id:1) {
    ...compareHotels
  }
  secondHotel: findHotelById(id:3) {
    ...compareHotels
  }
}

fragment compareHotels on Hotel {
    name
    room {
      type
      occupants
    }
}
```
>We have to use three dots followed by the fragment name to reuse a frament.

### Mutation

**Mutations** are used for **Create**, **Update** and **Delete** data (**CrUD**). We can create a mutation by replacing the _query_ with the _mutation_ keyword. This is an example:

```
mutation {
  newHotel(name:"test 1", address: "test 1"){
    id
  }
}
```
Just like in queries, if the mutation returns an object type, you can ask for nested fields. In the previous example the mutation creates a new _Hotel_ and returns the id for the created hotel, which was in this case autogenerated.

{% include elements/highlight.html text="Apart from sintax, queries and mutations differ from one more thing, query fields are executed in parallel, whereas mutations run sequencially." %}

## Conclusion

GraphQL is like an API gateway or proxy server that sits in front of your downstream services or data sources, and just like HTTP we can use verbs to get exactly what we ask for.

<p class="text-center">
{% include elements/button.html link="https://github.com/smartinrub/spring-boot-graphql" text="Source Code" %}
</p>
