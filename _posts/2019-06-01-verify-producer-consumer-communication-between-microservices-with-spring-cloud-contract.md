---
title: Verify Producer-Consumer Communication between Microservices with Spring Cloud Contract
tags: [Java, Spring, Testing, Microservices]
style: fill
color: success
description: In a microservices architecture, each microservice is developed independenly. This descentralization requires some kind of alignment to avoid incompatibilities. Keep reading to find out how to solve this new challenge with Spring Cloud Contract
---

{%- capture list_items -%}
Introduction
{%- endcapture -%}

{% include list.html title="Content" type="toc" %}

## Introduction

Before **microservices** became popular, we did not have to worry about making sure that different components of your application were using the same POJO class, and any change in a particular entity will affect all its users straight away.

In a microservices architecture, some **testing** aspects have changed, and now our applications **require a different strategy**. **Contract Testing** is one of the solutions which consists of writing tests to ensure that the contracts of our microservices are satisfied and work as expected.

When we talk about Contract Tests, there are **two roles**:

- **Producer**: it is the application providing a service.
- **Consumer**: it is entity consuming the producer API.

## What to test

Contracts should define API specifications offered by microservices, so there is no need for us to test service availability, integrations of layers or load tolerance. 

Our contract should contain elements like HTTP status (e.g. 200, 400...), headers (content-type, cookies...) or response body, for a particular request (method type + paht + ...).

## Tools

**[Spring Cloud Contract](https://spring.io/projects/spring-cloud-contract)** provides a simple way to test contracts by implementing the [Consumer-Driven Contracts](https://martinfowler.com/articles/consumerDrivenContracts.html) pattern. In this tecnique, consumers need to satisfy producers expectations, therefore providers are responsible for defining these contracts and share them with its consumers.

## Spring Cloud Contract

### Producer

We need to add this dependecy to the producer POM file:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-verifier</artifactId>
    <version>${contract.version}</version>
    <scope>test</scope>
</dependency>
```

Additionally, a plugin in the producer is required to generate tests and stubs for you.

```xml
<plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <baseClassForTests>com.sergiomartinrubio.reviewservice.BaseClass</baseClassForTests>
        <testMode>EXPLICIT</testMode>
    </configuration>
</plugin>
```

A few things need clarification: extensions of this plugin have to be enabled; we also have to say where the base class for the autogenerated test is; test mode needs to be `EXPLICIT`.

Now we can start writing our contracts and regardless how we write our REST endpoints, we will define them in _/src/test/resources/contracts/_ package, which is the default folder that Spring uses to generate tests and stubs. Bear in mind that contracts are written in Groovy and will be like the following one:

```groovy
package contracts

import org.springframework.cloud.contract.spec.Contract

Contract.make {

    description("should return all Reviews")

    request {
        method(GET())
        url("/reviews")
    }

    response {

        status(200)
        headers {
            contentType(applicationJsonUtf8())
        }

        body("""
            [
                {"id":"1", "author":"Sergio", "message":"content"}
            ]
        """)
    }

}
```

A base class is also required in order to set the context and mock responses.

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, properties = "server.port=0")
@RunWith(SpringRunner.class)
@Import(ProducerRestConfiguration.class)
public class BaseClass {

    @LocalServerPort
    private int port;

    @MockBean
    private ReviewRepository reviewRepository;

    @Before
    public void setUp() {

        RestAssured.baseURI = "http://localhost:" + this.port;

        when(reviewRepository.findAll())
                .thenReturn(Flux.just(new Review("1", "Sergio", "content")));

    }
}

```

Once the contract and base class are defined, we can run Maven to generate the tests and stubs.

```shell
mvn clean install
```

Tests will be generated in _/target/generated-test-sources/contracts/_. For the given example the output will be:

```java
public class ContractVerifierTest extends BaseClass {

	@Test
	public void validate_shouldReturnAllReviews() throws Exception {
		// given:
			RequestSpecification request = given();

		// when:
			Response response = given().spec(request)
					.get("/reviews");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
			assertThat(response.header("Content-Type")).matches("application/json;charset=UTF-8.*");
		// and:
			DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
			assertThatJson(parsedJson).array().contains("['message']").isEqualTo("content");
			assertThatJson(parsedJson).array().contains("['author']").isEqualTo("Sergio");
			assertThatJson(parsedJson).array().contains("['id']").isEqualTo("1");
	}

}
```

A stub will be also created to be used by consumers. This file will be a jar in /target (e.g. `review-service-0.0.1-SNAPSHOT-stubs.jar`).

### Consumer

The consumer will use a stub runner that allows you to automatically download stubs generated by the producer (or pick those from the classpath), start WireMock servers and feed them with stub definitions.

Consumer dependency:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
    <scope>test</scope>
</dependency>
```

Consumer test suite:

```java
@RunWith(SpringRunner.class)
@AutoConfigureStubRunner(ids = "com.sergiomartinrubio:review-service:+:8080",
        stubsMode = StubRunnerProperties.StubsMode.LOCAL)
@Import({ReviewConsumerApplication.class, ReviewClient.class})
public class ReviewWireMockTest {

    @Autowired
    private ReviewClient reviewClient;

    @Test
    public void clientShouldReturnReview() {
        StepVerifier.create(reviewClient.getAllReviews())
                .expectNextMatches(review -> review.getAuthor().equals("Sergio") && review.getMessage().equals("content"))
                .verifyComplete();
    }
}

```

`@AutoconfigurationStubRunner` will set: 

* ids:
    * _groupId_ of the artifact.
    * _artifactId_ of the producer.
    * producer version (+ means latest).
    * port on which the generated stub will run.
* stubsMode:
    * `StubRunnerProperties.StubsMode.CLASSPATH` (default value) - will pick stubs from the classpath.
    * `StubRunnerProperties.StubsMode.LOCAL` - will pick stubs from a local storage (e.g. _.m2_).
    * `StubRunnerProperties.StubsMode.REMOTE` - will pick stubs from a remote location.

As we mentioned, the consumer uses the stub generated by the producer, so if the producer changes the API the contract will break.

## Conclusion

<p class="text-center">
{% include button.html link="https://github.com/smartinrub/testing-spring-microservices" text="Source Code" %}
</p>

